---
benchmark_type: lxd
categories:
  -
    name: Network Configuration
    sub_category:
      name: 3.4 Firewall Configuration
      audit_tests:
        -
          name: '3.4.1.1 Ensure a Firewall package is installed (Automated)'
          description: A Firewall package should be selected. Most firewall configuration utilities operate as a front end to nftables or iptables.
          profile_applicability: Level 1
          audit:
            - 'dpkg -s ufw 2> /dev/null |grep Status |awk -F ":" ''{print $2}'' |awk ''FNR <= 1'''
            - 'dpkg -s nftables 2> /dev/null |grep Status |awk -F ":" ''{print $2}'' |awk ''FNR <= 1'''
            - 'dpkg -s iptables 2> /dev/null |grep Status |awk -F ":" ''{print $2}'' |awk ''FNR <= 1'''
          remediation: 'Run one of the following commands to install the Firewall package that follows local site policy:
                                     To install UFW, run the following command:
                                     # apt install ufw
                                     To install nftables, run the following command:
                                     # apt install nftables
                                     To install iptables, run the following command:
                                      # apt install iptables'
          check_type: multi_param
          eval_expr: "'$0' == 'install ok installed'; && '$1' == 'install ok installed'; && '$2' == 'install ok installed';"
        -
          name: '3.4.2.1 Ensure ufw service is enabled (Automated)'
          description: UncomplicatedFirewall (ufw) is a frontend for iptables. ufw provides a framework for managing netfilter, as well as a command-line and available graphical user interface for manipulating the firewall.
                      Ensure that the ufw service is enabled to protect your system.
          profile_applicability: Level 1
          audit:
            - 'systemctl is-enabled ufw 2> /dev/null'
          remediation: 'Remediation:
                        Run the following command to enable ufw:
                        # ufw enable'
          check_type: multi_param
          eval_expr: "'$0' == 'enabled';"
          referances:
            - http://manpages.ubuntu.com/manpages/precise/en/man8/ufw.8.html
          additional_info: 'When running ufw enable or starting ufw via its initscript, ufw will flush its chains. This is required so ufw can maintain a consistent state, but it may drop existing connections (eg ssh). ufw does support adding rules before enabling the firewall.
                            Run the following command before running ufw enable.
                            # ufw allow proto tcp from any to any port 22
                            The rules will still be flushed, but the ssh port will be open after enabling the firewall. Please note that once ufw is ''enabled'', ufw will not flush the chains when adding or removing rules (but will when modifying a rule or changing the default policy).
                            By default, ufw will prompt when enabling the firewall while running under ssh. This can be disabled by using ufw --force enable.'
        -
          name: '3.4.2.2 Ensure default deny firewall policy (Automated)'
          description: A default deny policy on connections ensures that any unconfigured network usage will be rejected.
          profile_applicability: Level 1
          audit:
            - 'ufw status verbose 2> /dev/null|grep Default: |awk -F ":" ''{print $2}'' |awk ''FNR <= 1'' |awk -F "," ''{print $1}'' |awk ''FNR <= 1'''
            - 'ufw status verbose 2> /dev/null|grep Default: |awk -F ":" ''{print $2}'' |awk ''FNR <= 1'' |awk -F "," ''{print $2}'' |awk ''FNR <= 1'''
            - 'ufw status verbose 2> /dev/null|grep Default: |awk -F ":" ''{print $2}'' |awk ''FNR <= 1'' |awk -F "," ''{print $3}'' |awk ''FNR <= 1'''
          remediation: 'Run the following commands to implement a default deny policy:
                        # ufw default deny incoming
                        # ufw default deny outgoing
                        # ufw default deny routed'
          check_type: multi_param
          eval_expr: "('$0' == 'deny (incoming)'; || '$0' == 'reject (incoming)';) && ('$1' == 'deny (outgoing)'; || '$1' == 'reject (outgoing)';) && ('$2' == 'deny (routed)'; || '$2' == 'reject (routed)';)"
        -
          name: '3.4.2.3 Ensure loopback traffic is configured (Automated)'
          description: Configure the loopback interface to accept traffic.
                       Configure all other interfaces to deny traffic to the loopback network (127.0.0.0/8 for IPv4 and ::1/128 for IPv6).
          profile_applicability: Level 1
          audit:
            - 'ufw status verbose 2> /dev/null | grep "Anywhere on lo" | grep "ALLOW IN" | awk -F " " ''{print $6}'' |awk ''FNR <= 1'''
            - 'ufw status verbose 2> /dev/null | grep "Anywhere" | grep "DENY IN" | awk -F " " ''{print $4}'' |awk ''FNR <= 1'''
            - 'ufw status verbose 2> /dev/null | grep "Anywhere (v6) on lo" | grep "ALLOW IN" | awk -F " " ''{print $7 $8}'' |awk ''FNR <= 1'''
            - 'ufw status verbose 2> /dev/null | grep "Anywhere (v6)" | grep "DENY IN" | awk -F " " ''{print $5}'' |awk ''FNR <= 1'''
            - 'ufw status verbose 2> /dev/null | grep "Anywhere" | grep "ALLOW OUT" | awk -F " " ''{print $4 $5 $6}'' |awk ''FNR <= 1'''
            - 'ufw status verbose 2> /dev/null | grep "Anywhere (v6)" | grep "ALLOW OUT" | awk -F " " ''{print $5 $6 $7 $8}'' |awk ''FNR <= 1'''
          remediation: 'Run the following commands to implement the loopback rules:
                        # ufw allow in on lo
                        # ufw allow out from lo
                        # sudo ufw deny in from 127.0.0.0/8
                        # sudo ufw deny in from ::1'
          check_type: multi_param
          eval_expr: "'$0' == 'Anywhere'; && '$1' == '127.0.0.0/8'; && '$2' == 'Anywhere(v6)'; && '$3' == '::1'; && '$4' == 'Anywhereonlo' && '$5' == 'Anywhere(v6)onlo';"
        -
          name: '3.4.2.4 Ensure outbound connections are configured (Manual)'
          description: Configure the firewall rules for new outbound connections.
          profile_applicability: Level 1
          audit:
            - 'ufw status numbered'
          remediation: 'Configure ufw in accordance with site policy. The following commands will implement a policy to allow all outbound connections on all interfaces:
                        # ufw allow out on all'
          check_type: multi_param
          additional_info: 'Changing firewall settings while connected over network can result in being locked out of the system.
                            Unlike iptables, when a new outbound rule is added, ufw automatically takes care of associated established connections,
                            so no rules for the latter kind are required.'
          type: manual

        -
          name: '3.4.2.5 Ensure firewall rules exist for all open ports (Automated)'
          description: Any ports that have been opened on non-loopback addresses need firewall rules to govern traffic.
          profile_applicability: Level 1
          audit:
            - 'ss -4tuln | grep -v 127.0.0 |grep -v lo |  wc -l'
            - 'ufw status | grep -v v6 | grep -v lo |grep -v 127.0.0 |wc -l'
          remediation: 'For each port identified in the audit which does not have a firewall rule establish a proper rule for accepting inbound connections:
                        # ufw allow in <port>/<tcp or udp protocol>
                        Additional Information:
                        Changing firewall settings while connected over network can result in being locked out of the system.
                        The remediation command opens up the port to traffic from all sources. Consult ufw documentation and set any restrictions in compliance with site policy.'
          check_type: multi_param
          eval_expr: "$0 > 1 && $1 > 5"
        -
          name: '3.4.3.1 Ensure iptables are flushed'
          description: nftables is a replacement for iptables, ip6tables, ebtables and arptables
          profile_applicability: Level 1
          audit:
            - 'iptables -n -L -v --line-numbers |grep num |  wc -l'
            - 'ip6tables -n -L -v --line-numbers |grep num |  wc -l'
          remediation: 'Run the following commands to flush iptables: For iptables:
                        # iptables -F
                        For ip6tables
                        # ip6tables -F'
          check_type: multi_param
          eval_expr: "$0 == 3"
        -
          name: '3.4.3.2 Ensure a table exists (Automated)'
          description: Tables hold chains. Each table only has one address family and only applies to packets of this family.
                        Tables can have one of five families.
          profile_applicability: Level 1
          audit:
            - 'nft list tables 2> /dev/null'
          remediation: 'Run the following command to create a table in nftables
                        # nft create table inet <table name>
                        Example:
                        # nft create table inet filter'
          check_type: multi_param
          eval_expr: "'$0' != '' && '$0' == 'table inet filter'"
        -
          name: '3.4.3.3 Ensure base chains exist (Automated)'
          description: Chains are containers for rules. They exist in two kinds, base chains and regular chains.
                        A base chain is an entry point for packets from the networking stack,
                        a regular chain may be used as jump target and is used for better rule organization.
          profile_applicability: Level 1
          audit:
            - 'nft list ruleset 2> /dev/null | grep ''hook input''| xargs |sed ''s/;//'' | sed ''s/;//'''
            - 'nft list ruleset 2> /dev/null | grep ''hook forward''| xargs |sed ''s/;//'' | sed ''s/;//'''
            - 'nft list ruleset 2> /dev/null | grep ''hook output''| xargs |sed ''s/;//'' | sed ''s/;//'''
          remediation: 'Run the following command to create the base chains:
                         # nft create chain inet <table name> <base chain name> { type filter hook <(input|forward|output)> priority 0 \; }
                         Example:
                         # nft create chain inet filter input { type filter hook input priority 0 \; }
                          # nft create chain inet filter forward { type filter hook forward priority 0 \; }
                          # nft create chain inet filter output { type filter hook output priority 0 \; }'
          check_type: multi_param
          eval_expr: "'$0' == 'type filter hook input priority 0 policy accept' && '$1' == 'type filter hook forward priority 0 policy accept'&& '$2' == 'type filter hook output priority 0 policy accept'"